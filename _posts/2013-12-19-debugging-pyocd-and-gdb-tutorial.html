---
layout: post
title: "debugging pyOCD gdb (tutorial)"
date: 2013-12-19
comments: true
categories:
 - pyOCD
 - tutorial
---

<div class='post'>
I finally found a root cause of pyOCD locking kinetis chip. It took me quite a while to get into gdb server implementation, still many functions are unveiled for me. I am going to give you few tips what I would do once something is not working, or even to be sure that the right binary is going to be flashed. That's was my case, when I knew that pyOCD is flashing wrong data to the wrong address.<br /><br />To start with, please if you use gdb server, change logging to DEBUG. This information is in gdb_test.py file.<br /><br /><pre class="brush: python">logging.basicConfig(level=logging.DEBUG)<br /></pre><br />What helped me a lot to just see how data are interpreted, disable erasing the chip and then flashing as well. The code below is from gdbserver.py file. Don't forget, if you change anything inside pyOCD, please rerun setup.py file with a command<br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">python setup.py install</span></span><br /><br />Comment out two lines that init() and eraseALL().<br /><pre class="brush: python">if ops == 'FlashErase':<br />    self.flash.init()<br />    self.flash.eraseAll()<br />    return self.createRSPPacket("OK")<br /></pre><br />Flashing is carried out by calling programPage. Once you comment that line out, your target won't be flashed, so you can add a breakpoint anywhere there, write data to a file and see how they are interpreted. <br /><pre class="brush: python">while len(self.flashData) &gt; 0:<br />    size_to_write = min(self.flash.page_size, len(self.flashData))<br />    #if 0 is returned from programPage, security check failed<br />    if (self.flash.programPage(flashPtr, self.flashData[:size_to_write]) == 0):<br />        logging.error("Protection bits error, flashing has stopped")<br />        return None<br />    flashPtr += size_to_write<br /><br />    self.flashData = self.flashData[size_to_write:]<br /><br />    # print progress bar<br />    sys.stdout.write('\r')<br />    i = int((float(flashPtr)/float(bytes_to_be_written))*20.0)<br />    # the exact output you're looking for:<br />    sys.stdout.write("[%-20s] %d%%" % ('='*i, 5*i))<br />    sys.stdout.flush()<br /></pre><br />There are many debug files commented in the implementation, which are intended for debugging purposes. The one below is from FlashDone command case, once you enable it, the bad_bin contains entire data which are going to be written to the flash. You can compare it to your bin generated, reveal if it matches the data.<br /><br /><pre class="brush: python">elif 'FlashDone' in ops :<br />    flashPtr = 0<br />    bytes_to_be_written = len(self.flashData)<br /><br />    """<br />    bin = open(os.path.join(parentdir, 'res', 'bad_bin.txt'), "w+")<br />    <br />    i = 0<br />    while (i &lt; bytes_to_be_written):<br />        bin.write(str(self.flashData[i:i+16]) + "\n")<br />        i += 16<br />    """<br /></pre><br />How did I solve that problem with locking the chip? The most important addition is the security bits check, which is crucial. If data at the address 0x400 are not set to 0xFF, flashing should be stopped. If it would not be stopped, the chip can get secured, depending on the 16 byte value at that address.<br />I added the following lines, this is why debug logging is good to have enabled, you can see how those bits are set and are going to be flashed. This would have unveiled that chip is going to get locked.<br /><br /><pre class="brush: python">def checkSecurityBits(self, address, data):<br />    #error if security bits have unexpected values<br />    if (address == 0x400):<br />        for i in range(12):<br />            logging.debug("data[%d] at add 0x%X: 0x%X", i, i, data[i])<br />            if (data[i] != 0xff):<br />                return 0<br /><br />        logging.debug("data[%d] at add 0x%X: 0x%X", i+3, i+3, data[i+3])<br />        logging.debug("data[%d] at add 0x%X: 0x%X", i+4, i+4, data[i+4])<br />        if ((data[i+3] != 0xff) or (data[i+4] != 0xff)):<br />            return 0<br /><br />    return 1<br /></pre><br />I even locked sometimes the chip (only security bit or some other bits, not mass erase bit). If chip is locked, mbed msd drive does not need to appear! Don't get frustrated. Follow the lines below, and you might get mbed drive again.<br />To solve this problem, get into bootloader mode (to disable CMSIS-DAP which enables another interface to access the mcu chip), use external jlink or just openSDA jlink. Execute the commands I shared in the previos post:<br /><a href="http://embeddedworldweb.blogspot.cz/2013/12/unlocking-kl25z-with-jlink-console.html">unlocking kinetis chip with jlink console [http://embeddedworldweb.blogspot.com]</a> <br />Don't be afraid if it returns error, sometimes it does but chip is functional again. Just reconnect your board, mbed drive should appear again if the chip is not bricked (like mass erase bit is set).<br /><br />To get familiar with gdb serial protocol, this link helps <br /><a href="http://www.embecosm.com/appnotes/ean4/embecosm-howto-rsp-server-ean4-issue-2.html">GDB Remote serial protocol [www.embecosm.com/appnotes/]</a><br /><br />I will add more chips to pyOCD. Finding the root cause of locking the kinetis chip provided a really appreciated lesson. Happy to contribute to pyOCD.<br /><br />Side note: the security check is on my branch at the moment - waiting for merge to the master branch. Don't use KL25Z with pyOCD from the origin master at the moment! You can lock your chip. Thanks for understanding.<br />To test the above features, here's link to my branch&nbsp; <a href="https://github.com/0xc0170/pyOCD/tree/dev_issue%231">dev issue#1 - security bits check [github.com/0xc0170]</a></div>
